package amanide.editors;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.jface.dialogs.IDialogSettings;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.IInformationControlCreator;
import org.eclipse.jface.text.ITextDoubleClickStrategy;
import org.eclipse.jface.text.presentation.IPresentationReconciler;
import org.eclipse.jface.text.presentation.PresentationReconciler;
import org.eclipse.jface.text.rules.DefaultDamagerRepairer;
import org.eclipse.jface.text.source.ISourceViewer;
import org.eclipse.ui.editors.text.TextSourceViewerConfiguration;

import amanide.AmanIDEPlugin;
import amanide.cache.ColorAndStyleCache;
import amanide.preferences.PilarEditorPrefs;
import amanide.utils.Log;

public class PilarConfigurationWithoutEditor extends TextSourceViewerConfiguration {
	private PilarDoubleClickStrategy doubleClickStrategy;
	
//	private PilarScanner scanner;
	
//	private ColorManager colorManager;
	
	private final Object lock = new Object();
	
	private PresentationReconciler reconciler;

  private PilarCodeScanner codeScanner;

  private PilarCommentScanner commentScanner;
  
  private PilarLocScanner locScanner;

  private PilarStringScanner stringScanner;
  
  private ColorAndStyleCache colorCache;
  
	public PilarConfigurationWithoutEditor(ColorAndStyleCache colorManager, IPreferenceStore preferenceStore) {
    super(preferenceStore);
    colorCache = colorManager;
}
	
	/**
   * Has to return all the types generated by partition scanner.
   * 
   * The SourceViewer will ignore double-clicks and any other configuration behaviors inside any partition not declared here
   */
  @Override
  public String[] getConfiguredContentTypes(ISourceViewer sourceViewer) {
      return new String[] { IDocument.DEFAULT_CONTENT_TYPE, IPilarPartitions.PILAR_SINGLELINE_COMMENT,
      		IPilarPartitions.PILAR_MULTILINE_COMMENT, IPilarPartitions.PILAR_MULTILINE_STRING, IPilarPartitions.PILAR_SINGLELINE_STRING1,
      		IPilarPartitions.PILAR_SINGLELINE_STRING2, IPilarPartitions.PILAR_LOC};
  }
  
  @Override
  public String getConfiguredDocumentPartitioning(ISourceViewer sourceViewer) {
      return IPilarPartitions.PILAR_PARTITION_TYPE;
  }
	
	@Override
	public ITextDoubleClickStrategy getDoubleClickStrategy(
		ISourceViewer sourceViewer,
		String contentType) {
		if (doubleClickStrategy == null)
			doubleClickStrategy = new PilarDoubleClickStrategy();
		return doubleClickStrategy;
	}

//	protected PilarScanner getPilarScanner() {
//		if (scanner == null) {
//			scanner = new PilarScanner(colorManager);
//			scanner.setDefaultReturnToken(
//				new Token(
//					new TextAttribute(
//						colorManager.getColor(IPilarColorConstants.DEFAULT))));
//		}
//		return scanner;
//	}

	@Override
	public IPresentationReconciler getPresentationReconciler(ISourceViewer sourceViewer) {
//		PresentationReconciler reconciler = new PresentationReconciler();

//		DefaultDamagerRepairer dr =
//			new DefaultDamagerRepairer(getPilarScanner());
//		reconciler.setDamager(dr, IDocument.DEFAULT_CONTENT_TYPE);
//		reconciler.setRepairer(dr, IDocument.DEFAULT_CONTENT_TYPE);
//
//		NonRuleBasedDamagerRepairer ndr =
//			new NonRuleBasedDamagerRepairer(
//				new TextAttribute(
//					colorManager.getColor(IPilarColorConstants.PILAR_COMMENT)));
//		reconciler.setDamager(ndr, PilarPartitionScanner.PILAR_COMMENT);
//		reconciler.setRepairer(ndr, PilarPartitionScanner.PILAR_COMMENT);

		synchronized (lock) {
      if (reconciler == null) {
        reconciler = new PresentationReconciler();
        reconciler.setDocumentPartitioning(IPilarPartitions.PILAR_PARTITION_TYPE);

        DefaultDamagerRepairer dr;

        // DefaultDamagerRepairer implements both IPresentationDamager, IPresentationRepairer
        // IPresentationDamager::getDamageRegion does not scan, just
        // returns the intersection of document event, and partition region
        // IPresentationRepairer::createPresentation scans
        // gets each token, and sets text attributes according to token

        // We need to cover all the content types from PilarPartitionScanner

        // Comments have uniform color
        commentScanner = new PilarCommentScanner(colorCache, PilarEditorPrefs.COMMENT_COLOR);
        dr = new DefaultDamagerRepairer(commentScanner);
        reconciler.setDamager(dr, IPilarPartitions.PILAR_SINGLELINE_COMMENT);
        reconciler.setRepairer(dr, IPilarPartitions.PILAR_SINGLELINE_COMMENT);
        reconciler.setDamager(dr, IPilarPartitions.PILAR_MULTILINE_COMMENT);
        reconciler.setRepairer(dr, IPilarPartitions.PILAR_MULTILINE_COMMENT);

        // Locs has uniform color
        locScanner = new PilarLocScanner(colorCache, PilarEditorPrefs.LOC_COLOR);
	      dr = new DefaultDamagerRepairer(locScanner);
	      reconciler.setDamager(dr, IPilarPartitions.PILAR_LOC);
	      reconciler.setRepairer(dr, IPilarPartitions.PILAR_LOC);

        // Strings have uniform color
        stringScanner = new PilarStringScanner(colorCache);
        dr = new DefaultDamagerRepairer(stringScanner);
        reconciler.setDamager(dr, IPilarPartitions.PILAR_SINGLELINE_STRING1);
        reconciler.setRepairer(dr, IPilarPartitions.PILAR_SINGLELINE_STRING1);
        reconciler.setDamager(dr, IPilarPartitions.PILAR_SINGLELINE_STRING2);
        reconciler.setRepairer(dr, IPilarPartitions.PILAR_SINGLELINE_STRING2);
        reconciler.setDamager(dr, IPilarPartitions.PILAR_MULTILINE_STRING);
        reconciler.setRepairer(dr, IPilarPartitions.PILAR_MULTILINE_STRING);

        // Default content is code, we need syntax highlighting
        ICodeScannerKeywords codeScannerKeywords = null;
        if (sourceViewer instanceof IAdaptable) {
            IAdaptable iAdaptable = (IAdaptable) sourceViewer;
            codeScannerKeywords = (ICodeScannerKeywords) iAdaptable.getAdapter(ICodeScannerKeywords.class);
            codeScanner = new PilarCodeScanner(colorCache, codeScannerKeywords);
        } else {
            codeScanner = new PilarCodeScanner(colorCache);
        }
        dr = new DefaultDamagerRepairer(codeScanner);
        reconciler.setDamager(dr, IDocument.DEFAULT_CONTENT_TYPE);
        reconciler.setRepairer(dr, IDocument.DEFAULT_CONTENT_TYPE);
      }
	  }
	
	  return reconciler;
	}

	/*
   * (non-Javadoc)
   * 
   * @see org.eclipse.jface.text.source.SourceViewerConfiguration#getInformationControlCreator(org.eclipse.jface.text.source.ISourceViewer)
   */
//  @Override
//  public IInformationControlCreator getInformationControlCreator(ISourceViewer sourceViewer) {
//      return ContentAssistant.createInformationControlCreator(sourceViewer);
//  }

  /**
   * Returns the settings for the given section.
   *
   * @param sectionName the section name
   * @return the settings
   * @since pydev 1.3.5
   */
  protected IDialogSettings getSettings(String sectionName) {
      IDialogSettings settings = AmanIDEPlugin.getDefault().getDialogSettings().getSection(sectionName);
      if (settings == null) {
          settings = AmanIDEPlugin.getDefault().getDialogSettings().addNewSection(sectionName);
      }

      return settings;
  }

  //updates the syntax highlighting for the specified preference
  //assumes that that editor colorCache has been updated with the
  //new named color
  public void updateSyntaxColorAndStyle() {
      synchronized (lock) {

          if (reconciler != null) {
              //always update all (too much work in keeping this synchronized by type)
              if (codeScanner != null) {
                  codeScanner.updateColors();
              }

              if (commentScanner != null) {
                  commentScanner.updateColorAndStyle();
              }

              if (stringScanner != null) {
                  stringScanner.updateColorAndStyle();
              }
          }
      }
  }
}